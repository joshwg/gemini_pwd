<!-- templates/index.html -->
{{define "title"}}Dashboard{{end}}

{{define "content"}}
<div class="flex gap-6">
    <!-- Left Sidebar - Tag Filter -->
    <div class="w-1/4 max-w-xs bg-white p-4 rounded-lg shadow-md h-fit" style="max-width: 280px;">
        <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-semibold text-gray-900">Filter by Tags</h3>
            <button id="clearTagFilters" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 px-3 py-1 rounded focus:outline-none focus:shadow-outline">
                Clear
            </button>
        </div>
        <div id="tagFilterList" class="space-y-1 max-h-[36rem] overflow-y-auto">
            <!-- Tag filter list will be populated here -->
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-1">
        <!-- Password Entries List -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <div class="flex items-center justify-between mb-4 flex-wrap gap-4">
                <h2 class="text-2xl font-semibold">Your Passwords</h2>
                <div class="flex items-center flex-wrap gap-2">
                    <input type="text" id="searchPassword" placeholder="Site or username..." class="shadow appearance-none border rounded py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline w-full sm:w-auto">
                    <button id="createPasswordBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline whitespace-nowrap" title="Create a new password entry">
                        <i class="fas fa-plus mr-2"></i>New Password
                    </button>
                </div>
            </div>
            <div id="passwordCardContainer" class="space-y-4">
                <!-- Password cards will be populated here by JavaScript -->
            </div>
        </div>
    </div>
</div>
    
</main>

<!-- Password Modal (Create/Edit) -->
<div id="passwordModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
    <div class="relative top-4 sm:top-20 mx-auto p-3 sm:p-5 border w-full max-w-4xl shadow-lg rounded-md bg-white">
        <div class="mt-3 text-center">
            <h3 class="text-lg leading-6 font-medium text-gray-900" id="passwordModalTitle"></h3>
            <div class="mt-2 px-3 sm:px-7 py-3">
                <form id="passwordForm">
                    <input type="hidden" id="passwordID" name="id">
                    <div class="mb-4">
                        <label for="passwordSite" class="block text-gray-700 text-sm font-bold mb-2 text-left">Site</label>
                        <input type="text" id="passwordSite" name="site" maxlength="256" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" required>
                        <div id="passwordSiteValidation" class="text-sm mt-1 hidden"></div>
                    </div>
                    <div class="mb-4">
                        <label for="passwordUsername" class="block text-gray-700 text-sm font-bold mb-2 text-left">Username</label>
                        <input type="text" id="passwordUsername" name="username" maxlength="128" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" required>
                        <div id="passwordUsernameValidation" class="text-sm mt-1 hidden"></div>
                    </div>
                    <div class="mb-4 relative">
                        <label for="passwordValue" class="block text-gray-700 text-sm font-bold mb-2 text-left">Password</label>
                        <input type="password" id="passwordValue" name="password" maxlength="128" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                        <span class="absolute right-3 top-9 cursor-pointer text-gray-500 hover:text-gray-700 toggle-password-visibility" data-target="passwordValue">
                            <i class="fas fa-eye"></i>
                        </span>
                        <div id="passwordValueValidation" class="text-sm mt-1 hidden"></div>
                    </div>
                    <div class="mb-4">
                        <label for="passwordNotes" class="block text-gray-700 text-sm font-bold mb-2 text-left">Notes</label>
                        <textarea id="passwordNotes" name="notes" rows="6" maxlength="4096" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline resize-vertical"></textarea>
                        <div id="passwordNotesValidation" class="text-sm mt-1 hidden"></div>
                    </div>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-8">
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2 text-left">Available Tags</label>
                            <div id="tagList" class="flex flex-wrap items-start content-start gap-1 p-2 border rounded-md bg-gray-300 h-48 overflow-y-auto">
                                <!-- Available tags will be populated here -->
                            </div>
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2 text-left">Password Tags</label>
                            <div id="passwordTagsContainer" class="flex flex-wrap items-start content-start gap-1 p-2 border rounded-md bg-gray-300 h-48 overflow-y-auto min-h-[40px]">
                                <!-- Tags associated with the password will be dropped here -->
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <button type="submit" id="passwordSubmitBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Save</button>
                        <button type="button" class="close-modal bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<style>
    /* Enhanced interactivity for available tags */
    #tagList .tag-item {
        transition: all 0.2s ease;
        user-select: none;
    }
    
    #tagList .tag-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        opacity: 0.9;
    }
    
    #tagList .tag-item:active {
        transform: translateY(0);
    }
    
    /* Mobile touch feedback */
    @media (hover: none) and (pointer: coarse) {
        #tagList .tag-item {
            cursor: pointer !important;
        }
        
        #tagList .tag-item:active {
            transform: scale(0.98);
            opacity: 0.8;
        }
    }
    
    /* Responsive adjustments for narrow screens */
    @media (max-width: 640px) {
        /* Reduce font sizes on very small screens */
        .text-2xl {
            font-size: 1.25rem !important;
        }
        
        /* Stack sidebar and main content vertically on mobile */
        .flex.gap-6 {
            flex-direction: column !important;
        }
        
        .w-1\/4 {
            width: 100% !important;
        }
        
        /* Make cards more compact on mobile */
        .grid-cols-12 {
            display: block !important;
        }
        
        .grid-cols-12 > div {
            margin-bottom: 1rem;
        }
        
        .grid-cols-12 > div:last-child {
            margin-bottom: 0;
        }
        
        /* Stack password fields vertically on mobile */
        .password-display {
            min-width: 0 !important;
            width: 100% !important;
        }
        
        /* Make action buttons full width on mobile */
        .col-span-12.sm\\:col-span-2 {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        
        /* Reduce card padding on mobile */
        #passwordCardContainer .p-4 {
            padding: 1rem !important;
        }
        
        /* Make tags section full width on mobile */
        .lg\\:grid-cols-2 {
            grid-template-columns: 1fr !important;
        }
    }
    
    @media (max-width: 480px) {
        /* Extra small screens */
        .password-display {
            font-size: 0.75rem !important;
        }
        
        /* Even more compact cards */
        #passwordCardContainer .p-4 {
            padding: 0.75rem !important;
        }
        
        /* Smaller action buttons */
        .edit-password-btn, .delete-password-btn {
            padding: 0.5rem !important;
        }
    }
</style>

<script>
    const API_ORIGIN = window.location.origin;
    const DEFAULT_TAG_COLOR = '#6B7280'; // dark gray - matches backend defaultTagColor
    
    // Global authentication handler for AJAX requests
    async function handleAuthResponse(response) {
        // Check for authentication errors
        if (response.status === 401 || response.status === 403) {
            alert('Your session has expired. You will be redirected to the login page.');
            window.location.href = '/logout';
            return null;
        }
        
        // Check if response is HTML (likely a redirect to login page)
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('text/html') && !response.ok) {
            // If we got HTML when expecting JSON, it's likely a redirect to login
            alert('Your session has expired. You will be redirected to the login page.');
            window.location.href = '/logout';
            return null;
        }
        
        return response;
    }
    
    // Enhanced fetch function that handles authentication
    async function authFetch(url, options = {}) {
        try {
            const response = await fetch(url, options);
            const authResponse = await handleAuthResponse(response);
            return authResponse;
        } catch (error) {
            console.error('Fetch error:', error);
            throw error;
        }
    }
    
    // Utility function to get tag color with fallback to default
    function getTagColor(color) {
        return color && color.trim() !== '' ? color : DEFAULT_TAG_COLOR;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const passwordCardContainer = document.getElementById('passwordCardContainer');
        const searchPasswordInput = document.getElementById('searchPassword');
        const createPasswordBtn = document.getElementById('createPasswordBtn');
        const passwordModal = document.getElementById('passwordModal');
        const passwordForm = document.getElementById('passwordForm');
        const passwordModalTitle = document.getElementById('passwordModalTitle');
        const passwordID = document.getElementById('passwordID');
        const passwordSite = document.getElementById('passwordSite');
        const passwordUsername = document.getElementById('passwordUsername');
        const passwordValue = document.getElementById('passwordValue');
        const passwordNotes = document.getElementById('passwordNotes');
        const passwordTagsContainer = document.getElementById('passwordTagsContainer');
        
        // Tag filtering elements
        const tagFilterList = document.getElementById('tagFilterList');
        const clearTagFilters = document.getElementById('clearTagFilters');
        
        // Password validation elements
        const passwordSiteValidation = document.getElementById('passwordSiteValidation');
        const passwordUsernameValidation = document.getElementById('passwordUsernameValidation');
        const passwordValueValidation = document.getElementById('passwordValueValidation');
        const passwordSubmitBtn = document.getElementById('passwordSubmitBtn');

        let allTags = [];
        let draggedTag = null;
        
        // Function to determine text color based on background color brightness
        function getTextColor(backgroundColor) {
            // Convert hex to RGB
            const hex = backgroundColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Calculate brightness using relative luminance formula
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            
            // Return black for light colors, white for dark colors
            return brightness > 155 ? '#000000' : '#FFFFFF';
        }
        
        // Function to get border style for tags based on background brightness
        function getBorderStyle(backgroundColor) {
            // Convert hex to RGB
            const hex = backgroundColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Calculate brightness using relative luminance formula
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            
            // For very light colors (brightness > 220), use a darker border
            if (brightness > 220) {
                return '2px solid #666666'; // Dark gray border for very light tags
            } else if (brightness > 180) {
                return '1px solid #777777'; // Medium gray border for light tags
            } else {
                return '1px solid #eeeeee'; // Light gray border for darker tags
            }
        }
        
        // Function to sort tags alphabetically within a container
        function sortTagsInContainer(container) {
            const tags = Array.from(container.querySelectorAll('.tag-item'));
            tags.sort((a, b) => {
                const nameA = a.dataset.name.toLowerCase();
                const nameB = b.dataset.name.toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            // Remove all tags and re-add them in sorted order
            tags.forEach(tag => tag.remove());
            tags.forEach(tag => container.appendChild(tag));
        }
        
        // Tag filtering state
        let selectedTagFilterIds = new Set();
        
        // Fetch tags and show initial empty state on page load
        fetchTags();
        showEmptyFilterState(); // Show the filter prompt instead of loading passwords

        // Search functionality
        searchPasswordInput.addEventListener('keyup', () => {
            applyFilters();
        });
        
        // Tag filter functionality
        clearTagFilters.addEventListener('click', () => {
            selectedTagFilterIds.clear();
            renderTagFilterList(allTags); // Re-render to update selection state
            applyFilters();
        });

        // Function to check if any filters are currently active
        function hasActiveFilters() {
            const searchQuery = searchPasswordInput.value.toLowerCase().trim();
            return searchQuery !== '' || selectedTagFilterIds.size > 0;
        }

        // Function to fetch passwords with server-side filtering
        async function fetchFilteredPasswords() {
            if (!hasActiveFilters()) {
                showEmptyFilterState();
                return;
            }
            
            try {
                // Build query parameters for server-side filtering
                const params = new URLSearchParams();
                
                // Add text search parameter
                const searchQuery = searchPasswordInput.value.trim();
                if (searchQuery) {
                    params.append('q', searchQuery);
                }
                
                // Add tag filter parameters
                if (selectedTagFilterIds.size > 0) {
                    params.append('tags', Array.from(selectedTagFilterIds).join(','));
                }
                
                // Add limit parameter
                params.append('limit', '100');
                
                const response = await authFetch(API_ORIGIN + '/api/passwords?' + params.toString());
                if (!response) return; // Auth error handled by authFetch
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error('Failed to fetch passwords: ' + response.status + ' ' + response.statusText + ' - ' + errorText);
                }
                const passwords = await response.json() || [];
                renderPasswords(passwords);
            } catch (e) {
                console.error('Error in fetchFilteredPasswords:', e);
                alert('Could not fetch passwords. See console for details.');
            }
        }

        // Function to apply both text search and tag filters (now uses server-side filtering)
        async function applyFilters() {
            await fetchFilteredPasswords();
        }

        // Function to show empty state when no filters are applied
        function showEmptyFilterState() {
            passwordCardContainer.innerHTML = '';
            const emptyCard = document.createElement('div');
            emptyCard.className = 'bg-blue-50 border-2 border-dashed border-blue-300 rounded-lg p-8 text-center';
            emptyCard.innerHTML = 
                '<div class="flex flex-col items-center">' +
                    '<i class="fas fa-search text-4xl text-blue-300 mb-4"></i>' +
                    '<p class="text-lg font-medium text-blue-600 mb-2">Apply filters to view passwords</p>' +
                    '<p class="text-sm text-blue-500">Select a tag or search by site/username to see your passwords</p>' +
                '</div>';
            passwordCardContainer.appendChild(emptyCard);
        }

        // Function to check for duplicate passwords via API
        async function checkPasswordDuplicate(site, username, id = null) {
            try {
                const response = await authFetch('/api/passwords/check-duplicate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        site: site,
                        username: username,
                        id: id
                    })
                });
                
                if (!response) return false; // Auth error handled by authFetch
                if (!response.ok) {
                    // Log the error but don't throw - return false to allow form submission
                    console.error('Duplicate check failed:', response.status, response.statusText);
                    return false;
                }
                
                const result = await response.json();
                // Ensure we return a boolean value, never undefined or null
                return Boolean(result && result.isDuplicate);
            } catch (e) {
                // Log error but return false to avoid blocking user
                console.error('Error checking duplicate:', e);
                return false;
            }
        }

        // Open password creation modal
        createPasswordBtn.addEventListener('click', () => {
            passwordModalTitle.textContent = 'Create New Password';
            passwordForm.reset();
            passwordID.value = '';
            passwordTagsContainer.innerHTML = '';
            // Reset validation state
            passwordSiteValidation.classList.add('hidden');
            passwordUsernameValidation.classList.add('hidden');
            passwordValueValidation.classList.add('hidden');
            const notesValidation = document.getElementById('passwordNotesValidation');
            if (notesValidation) {
                notesValidation.classList.add('hidden');
            }
            passwordSubmitBtn.disabled = true;
            passwordSubmitBtn.classList.add('opacity-50', 'cursor-not-allowed');
            passwordSubmitBtn.classList.remove('hover:bg-blue-700');
            // Reset validation cache
            lastValidationParams = null;
            clearTimeout(validationTimeout);
            // Reset password field type and icon using global function
            if (typeof resetPasswordToggles === 'function') {
                resetPasswordToggles();
            }
            // Refresh available tags to show all tags
            refreshAvailableTags();
            passwordModal.classList.remove('hidden');
            
            // Run initial validation to set proper button state
            setTimeout(() => {
                performRealTimeValidation();
            }, 100);
        });

        // Handle form submissions for passwords
        passwordForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Check validation before submitting
            if (!validatePasswordForm()) {
                return;
            }
            
            const tags = Array.from(passwordTagsContainer.querySelectorAll('.tag-item')).map(tag => tag.dataset.name);
            
            const data = {
                site: passwordSite.value,
                username: passwordUsername.value,
                password: passwordValue.value,
                notes: passwordNotes.value,
                tags: tags
            };

            // Add ID to data if it's an update (PUT request)
            const method = passwordID.value ? 'PUT' : 'POST';
            if (method === 'PUT') {
                data.id = parseInt(passwordID.value);
            }
            const url = passwordID.value ? (API_ORIGIN + '/api/passwords?id=' + passwordID.value) : (API_ORIGIN + '/api/passwords');

            const response = await authFetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (!response) return; // Auth error handled by authFetch
            if (response.ok) {
                console.log('Password saved successfully!');
                passwordModal.classList.add('hidden');
                await applyFilters(); // Use the new server-side filtering approach
            } else {
                console.error('Failed to save password.');
                const errorText = await response.text();
                alert('Error: ' + errorText);
            }
        });

        // Event delegation for table and tag list buttons
        document.addEventListener('click', async (e) => {
            if (e.target.closest('.delete-password-btn')) {
                const id = e.target.closest('.delete-password-btn').dataset.id;
                if (confirm('Are you sure you want to delete this password?')) {
                    const response = await authFetch(API_ORIGIN + '/api/passwords?id=' + id, { method: 'DELETE' });
                    if (!response) return; // Auth error handled by authFetch
                    if (response.ok) {
                        await applyFilters(); // Use the new server-side filtering approach
                    } else {
                        alert('Failed to delete password.');
                    }
                }
            } else if (e.target.closest('.edit-password-btn')) {
                const id = e.target.closest('.edit-password-btn').dataset.id;
                fetchPasswordByID(id);
            } else if (e.target.closest('.copy-password-btn')) {
                const id = e.target.closest('.copy-password-btn').dataset.id;
                copyPassword(id);
            } else if (e.target.closest('.show-password-btn')) {
                const id = e.target.closest('.show-password-btn').dataset.id;
                showHidePassword(id);
            } else if (e.target.closest('.show-notes-btn')) {
                const id = e.target.closest('.show-notes-btn').dataset.id;
                showHideNotes(id);
            } else if (e.target.closest('.close-modal')) {
                // Reset validation state when closing modal
                if (e.target.closest('#passwordModal')) {
                    passwordSiteValidation.classList.add('hidden');
                    passwordUsernameValidation.classList.add('hidden');
                    passwordValueValidation.classList.add('hidden');
                    const notesValidation = document.getElementById('passwordNotesValidation');
                    if (notesValidation) {
                        notesValidation.classList.add('hidden');
                    }
                    passwordSubmitBtn.disabled = true;
                    passwordSubmitBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    passwordSubmitBtn.classList.remove('hover:bg-blue-700');
                    // Reset validation cache
                    lastValidationParams = null;
                    clearTimeout(validationTimeout);
                    // Reset password field type and icon using global function
                    if (typeof resetPasswordToggles === 'function') {
                        resetPasswordToggles();
                    }
                    // Refresh available tags to restore all tags
                    refreshAvailableTags();
                }
                e.target.closest('.fixed').classList.add('hidden');
            }
        });

        // Password form validation
        function validatePasswordForm() {
            let isValid = true;

            // Validate site field
            const site = passwordSite.value.trim();
            if (site === '') {
                passwordSiteValidation.textContent = 'Site is required';
                passwordSiteValidation.className = 'text-sm mt-1 text-red-600';
                passwordSiteValidation.classList.remove('hidden');
                isValid = false;
            } else if (site.length > 256) {
                passwordSiteValidation.textContent = 'Site must be 256 characters or less';
                passwordSiteValidation.className = 'text-sm mt-1 text-red-600';
                passwordSiteValidation.classList.remove('hidden');
                isValid = false;
            } else {
                passwordSiteValidation.classList.add('hidden');
            }

            // Validate username field
            const username = passwordUsername.value.trim();
            if (username === '') {
                passwordUsernameValidation.textContent = 'Username is required';
                passwordUsernameValidation.className = 'text-sm mt-1 text-red-600';
                passwordUsernameValidation.classList.remove('hidden');
                isValid = false;
            } else if (username.length > 128) {
                passwordUsernameValidation.textContent = 'Username must be 128 characters or less';
                passwordUsernameValidation.className = 'text-sm mt-1 text-red-600';
                passwordUsernameValidation.classList.remove('hidden');
                isValid = false;
            } else {
                // Check for duplicates asynchronously
                checkDuplicateAsync(site, username, passwordID.value);
            }

            // Validate password field (optional, but with length limits)
            const password = passwordValue.value;
            if (password.length > 128) {
                passwordValueValidation.textContent = 'Password must be 128 characters or less';
                passwordValueValidation.className = 'text-sm mt-1 text-red-600';
                passwordValueValidation.classList.remove('hidden');
                isValid = false;
            } else {
                passwordValueValidation.classList.add('hidden');
            }

            // Validate notes field (optional, but with length limits)
            const notes = passwordNotes.value;
            if (notes.length > 4096) {
                // Add validation div for notes if it doesn't exist
                let notesValidation = document.getElementById('passwordNotesValidation');
                if (!notesValidation) {
                    notesValidation = document.createElement('div');
                    notesValidation.id = 'passwordNotesValidation';
                    notesValidation.className = 'text-sm mt-1 hidden';
                    passwordNotes.parentNode.appendChild(notesValidation);
                }
                notesValidation.textContent = 'Notes must be 4096 characters or less';
                notesValidation.className = 'text-sm mt-1 text-red-600';
                notesValidation.classList.remove('hidden');
                isValid = false;
            } else {
                const notesValidation = document.getElementById('passwordNotesValidation');
                if (notesValidation) {
                    notesValidation.classList.add('hidden');
                }
            }

            // Enable/disable submit button with visual feedback
            passwordSubmitBtn.disabled = !isValid;
            if (isValid) {
                passwordSubmitBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                passwordSubmitBtn.classList.add('hover:bg-blue-700');
            } else {
                passwordSubmitBtn.classList.add('opacity-50', 'cursor-not-allowed');
                passwordSubmitBtn.classList.remove('hover:bg-blue-700');
            }
            return isValid;
        }

        // Async function to check for duplicates
        async function checkDuplicateAsync(site, username, currentID) {
            const currentIDNumber = currentID ? parseInt(currentID) : null;
            
            // Only check for duplicates when creating new password or editing with different site/username
            if (site && username) {
                try {
                    const isDuplicate = await checkPasswordDuplicate(site, username, currentIDNumber);
                    
                    if (isDuplicate) {
                        passwordUsernameValidation.textContent = 'A password for this site and username already exists';
                        passwordUsernameValidation.className = 'text-sm mt-1 text-red-600';
                        passwordUsernameValidation.classList.remove('hidden');
                        passwordSubmitBtn.disabled = true;
                        passwordSubmitBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        passwordSubmitBtn.classList.remove('hover:bg-blue-700');
                    } else {
                        passwordUsernameValidation.classList.add('hidden');
                        // Re-run basic validation to update submit button state
                        validatePasswordForm();
                    }
                } catch (e) {
                    console.error('Error in checkDuplicateAsync:', e);
                    // On error, hide validation and allow form submission
                    passwordUsernameValidation.classList.add('hidden');
                    validatePasswordForm();
                }
            } else {
                passwordUsernameValidation.classList.add('hidden');
            }
        }

        // Real-time validation function that combines basic validation and duplicate checking
        let validationTimeout;
        let lastValidationParams = null; // Cache to avoid duplicate API calls
        
        function performRealTimeValidation() {
            // Clear existing timeout
            clearTimeout(validationTimeout);
            
            // Run basic validation immediately
            const basicValidationPassed = validatePasswordForm();
            
            // If basic validation passes, check for duplicates with delay
            if (basicValidationPassed) {
                const site = passwordSite.value.trim();
                const username = passwordUsername.value.trim();
                const currentID = passwordID.value;
                
                // Create a key for caching to avoid duplicate API calls
                const validationKey = `${site}|${username}|${currentID}`;
                
                // Only make API call if parameters have changed
                if (site && username && validationKey !== lastValidationParams) {
                    validationTimeout = setTimeout(async () => {
                        lastValidationParams = validationKey;
                        await checkDuplicateAsync(site, username, currentID);
                    }, 500); // 500ms delay to avoid too many API calls
                }
            } else {
                // If basic validation fails, clear the cache
                lastValidationParams = null;
            }
        }

        // Add event listeners for real-time validation on all form fields
        passwordSite.addEventListener('input', performRealTimeValidation);
        passwordUsername.addEventListener('input', performRealTimeValidation);
        passwordValue.addEventListener('input', performRealTimeValidation);
        passwordNotes.addEventListener('input', performRealTimeValidation);

        // Drag and drop for tags
        document.getElementById('tagList')?.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('tag-item')) {
                draggedTag = e.target;
                e.dataTransfer.setData('text/plain', e.target.dataset.id);
            }
        });

        passwordTagsContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        passwordTagsContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedTag) {
                addTagToPassword(draggedTag);
                draggedTag = null;
            }
        });

        // Function to refresh available tags after tag is removed from password tags
        function refreshAvailableTags() {
            if (window.allAvailableTags) {
                renderTags(window.allAvailableTags);
            }
        }

        // Function to add a tag to password tags (used by both drag/drop and click)
        function addTagToPassword(sourceTagElement) {
            const tagId = sourceTagElement.dataset.id;
            const tagName = sourceTagElement.dataset.name;
            const tagColor = getTagColor(sourceTagElement.dataset.color);
            
            // Prevent duplicate tags
            if (passwordTagsContainer.querySelector('[data-id="' + tagId + '"]')) {
                return false; // Tag already exists
            }
            
            const tagElement = document.createElement('span');
            tagElement.className = 'tag-item text-xs font-semibold inline-block py-0.5 px-3 rounded border last:mr-0 mr-1 cursor-pointer break-all';
            tagElement.style.backgroundColor = tagColor;
            tagElement.style.color = getTextColor(tagColor);
            tagElement.style.border = getBorderStyle(tagColor);
            tagElement.dataset.id = tagId;
            tagElement.dataset.name = tagName;
            tagElement.dataset.color = tagColor;
            tagElement.draggable = true;
            tagElement.textContent = tagName;
            tagElement.addEventListener('click', () => {
                tagElement.remove();
                // Add tag back to available tags when removed
                refreshAvailableTags();
                // Sort remaining password tags
                sortTagsInContainer(passwordTagsContainer);
                // Trigger validation when tags change
                performRealTimeValidation();
            });
            passwordTagsContainer.appendChild(tagElement);
            
            // Sort tags in the password tags container
            sortTagsInContainer(passwordTagsContainer);
            
            // Remove tag from available tags
            sourceTagElement.remove();
            
            // Sort remaining available tags
            const tagListContainer = document.getElementById('tagList');
            if (tagListContainer) {
                sortTagsInContainer(tagListContainer);
            }
            
            // Trigger validation when tags are added
            performRealTimeValidation();
            
            return true; // Tag successfully added
        }

        // Helper functions        
        async function fetchPasswordByID(id) {
            try {
                const response = await authFetch(API_ORIGIN + '/api/passwords?id=' + id);
                if (!response) return; // Auth error handled by authFetch
                if (!response.ok) throw new Error('Failed to fetch password.');
                const password = await response.json();
                passwordModalTitle.textContent = 'Edit Password';
                passwordID.value = password.id;
                passwordSite.value = password.site;
                passwordUsername.value = password.username;
                passwordNotes.value = password.notes;
                
                // Clear and populate tags
                passwordTagsContainer.innerHTML = '';
                password.tags.forEach(tag => {
                    const tagColor = getTagColor(tag.color);
                    const tagElement = document.createElement('span');
                    tagElement.className = 'tag-item text-xs font-semibold inline-block py-0.5 px-3 rounded border last:mr-0 mr-1 cursor-pointer break-all';
                    tagElement.style.backgroundColor = tagColor;
                    tagElement.style.color = getTextColor(tagColor);
                    tagElement.style.border = getBorderStyle(tagColor);
                    tagElement.dataset.id = tag.id;
                    tagElement.dataset.name = tag.name;
                    tagElement.dataset.color = tagColor;
                    tagElement.draggable = true;
                    tagElement.textContent = tag.name;
                    tagElement.addEventListener('click', () => {
                        tagElement.remove();
                        // Add tag back to available tags when removed
                        refreshAvailableTags();
                        // Sort remaining password tags
                        sortTagsInContainer(passwordTagsContainer);
                        // Trigger validation when tags change
                        performRealTimeValidation();
                    });
                    passwordTagsContainer.appendChild(tagElement);
                });
                
                // Sort the password tags
                sortTagsInContainer(passwordTagsContainer);
                
                // Refresh available tags to exclude already used ones
                refreshAvailableTags();
                
                // Reset validation state and trigger validation
                passwordSiteValidation.classList.add('hidden');
                passwordUsernameValidation.classList.add('hidden');
                passwordValueValidation.classList.add('hidden');
                const notesValidation = document.getElementById('passwordNotesValidation');
                if (notesValidation) {
                    notesValidation.classList.add('hidden');
                }
                // Reset validation cache
                lastValidationParams = null;
                clearTimeout(validationTimeout);
                // Reset password field type and icon using global function
                if (typeof resetPasswordToggles === 'function') {
                    resetPasswordToggles();
                }
                
                // Run real-time validation for edit mode
                setTimeout(() => {
                    performRealTimeValidation();
                }, 100);
                
                passwordModal.classList.remove('hidden');
            } catch (e) {
                console.error(e);
                alert(String(e));
            }
        }

        async function fetchTags() {
            try {
                const response = await authFetch(API_ORIGIN + '/api/tags');
                if (!response) return; // Auth error handled by authFetch
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error('Failed to fetch tags: ' + response.status + ' ' + response.statusText + ' - ' + errorText);
                }
                allTags = await response.json() || [];
                renderTags(allTags);
                renderTagFilterList(allTags);
            } catch (e) {
                console.error('Error in fetchTags:', e);
                alert('Could not fetch tags. See console for details.');
            }
        }
        
        // Function to render the tag filter list in the sidebar
        function renderTagFilterList(tags) {
            tagFilterList.innerHTML = '';
            
            if (tags.length === 0) {
                tagFilterList.innerHTML = '<div class="text-sm text-gray-500 text-center py-4">No tags available</div>';
                return;
            }
            
            // Sort tags alphabetically
            const sortedTags = [...tags].sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
            
            sortedTags.forEach(tag => {
                const tagColor = getTagColor(tag.color);
                const textColor = getTextColor(tagColor);
                const isSelected = selectedTagFilterIds.has(tag.id.toString());
                
                const tagElement = document.createElement('span');
                
                if (isSelected) {
                    // Selected tags: keep the same compact style but with selection styling
                    tagElement.className = 'tag-filter-item cursor-pointer text-xs font-semibold inline-block py-0.5 px-2 rounded border mr-1 mb-1 ring-2 ring-blue-500 ring-opacity-50';
                    tagElement.style.backgroundColor = '#1e40af'; // Blue-800
                    tagElement.style.color = '#ffffff';
                    tagElement.style.border = '1px solid #1d4ed8'; // Blue-700
                } else {
                    // Unselected tags: exact same style as password card tags
                    tagElement.className = 'tag-filter-item cursor-pointer text-xs font-semibold inline-block py-0.5 px-2 rounded border mr-1 mb-1 hover:opacity-80 transition-all';
                    tagElement.style.backgroundColor = tagColor;
                    tagElement.style.color = textColor;
                    tagElement.style.border = getBorderStyle(tagColor);
                }
                
                tagElement.dataset.tagId = tag.id;
                tagElement.textContent = tag.name;
                
                tagElement.addEventListener('click', () => {
                    toggleTagFilter(tag.id.toString(), tag.name, tagColor, textColor);
                });
                
                tagFilterList.appendChild(tagElement);
            });
        }
        
        // Function to toggle a tag filter
        function toggleTagFilter(tagId, tagName, tagColor, textColor) {
            if (selectedTagFilterIds.has(tagId)) {
                selectedTagFilterIds.delete(tagId);
            } else {
                selectedTagFilterIds.add(tagId);
            }
            
            renderTagFilterList(allTags); // Re-render to update selection state
            applyFilters();
        }

        function renderPasswords(passwords) {
            passwordCardContainer.innerHTML = '';
            
            // Handle empty state
            if (passwords.length === 0) {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-8 text-center';
                emptyCard.innerHTML = 
                    '<div class="flex flex-col items-center">' +
                        '<i class="fas fa-key text-4xl text-gray-300 mb-4"></i>' +
                        '<p class="text-lg font-medium text-gray-500 mb-2">No passwords found</p>' +
                        '<p class="text-sm text-gray-400">Add your first password to get started</p>' +
                    '</div>';
                passwordCardContainer.appendChild(emptyCard);
                return;
            }
            
            passwords.forEach(p => {
                // Create main card container
                const card = document.createElement('div');
                card.className = 'bg-white border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow duration-200';
                card.id = 'password-card-' + p.id;
                
                // Generate tags HTML
                const tagsHTML = p.tags.map(tag => {
                    const tagColor = getTagColor(tag.color);
                    const textColor = getTextColor(tagColor);
                    const borderStyle = getBorderStyle(tagColor);
                    return '<span class="tag-item text-xs font-semibold inline-block py-0.5 px-2 rounded border mr-1 mb-1" style="background-color: ' + tagColor + '; color: ' + textColor + '; border: ' + borderStyle + ';">' + tag.name + '</span>';
                }).join('');
                
                // Password display area with show/hide and copy functionality
                const passwordHTML = 
                    '<div class="flex items-center gap-2 relative">' +
                        '<input type="password" id="password-' + p.id + '" class="password-display flex-1 py-1 px-2 text-sm border rounded bg-gray-50" placeholder="••••••••" readonly>' +
                        '<button class="show-password-btn p-1 transform hover:text-blue-500 hover:scale-110" data-id="' + p.id + '" title="Show/Hide password"><i class="fas fa-eye"></i></button>' +
                        '<button class="copy-password-btn p-1 transform hover:text-green-500 hover:scale-110" data-id="' + p.id + '" title="Copy password to clipboard"><i class="fas fa-copy"></i></button>' +
                        '<div id="copy-message-' + p.id + '" class="absolute right-0 top-full mt-1 bg-green-500 text-white text-xs px-2 py-1 rounded shadow-lg hidden z-10">' +
                            '<i class="fas fa-check mr-1"></i>Copied!' +
                        '</div>' +
                    '</div>';
                
                // Card HTML structure
                card.innerHTML = 
                    '<div class="p-4">' +
                        '<!-- First Row: Site, Username, Password, Actions -->' +
                        '<div class="grid grid-cols-12 gap-4 items-center mb-3">' +
                            '<div class="col-span-12 sm:col-span-3">' +
                                '<label class="text-xs text-gray-500 uppercase tracking-wide">Site</label>' +
                                '<div class="font-medium text-gray-900 break-all">' + p.site + '</div>' +
                            '</div>' +
                            '<div class="col-span-12 sm:col-span-3">' +
                                '<label class="text-xs text-gray-500 uppercase tracking-wide">Username</label>' +
                                '<div class="font-medium text-gray-700 break-all">' + p.username + '</div>' +
                            '</div>' +
                            '<div class="col-span-12 sm:col-span-4">' +
                                '<label class="text-xs text-gray-500 uppercase tracking-wide">Password</label>' +
                                '<div class="mt-1">' + passwordHTML + '</div>' +
                            '</div>' +
                            '<div class="col-span-12 sm:col-span-2 text-center">' +
                                '<label class="text-xs text-gray-500 uppercase tracking-wide">Actions</label>' +
                                '<div class="flex justify-center gap-2 mt-1">' +
                                    '<button class="edit-password-btn p-2 text-gray-500 hover:text-blue-500 hover:bg-blue-50 rounded transition-colors" data-id="' + p.id + '" title="Edit password"><i class="fas fa-edit"></i></button>' +
                                    '<button class="delete-password-btn p-2 text-gray-500 hover:text-red-500 hover:bg-red-50 rounded transition-colors" data-id="' + p.id + '" title="Delete password"><i class="fas fa-trash-alt"></i></button>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                        '<!-- Second Row: Tags and Notes -->' +
                        '<div class="grid grid-cols-1 lg:grid-cols-2 gap-4 pt-3 border-t border-gray-100">' +
                            '<div class="tags-container">' +
                                '<div class="flex items-center mb-2">' +
                                    '<span class="text-xs text-gray-500 uppercase tracking-wide">Tags</span>' +
                                '</div>' +
                                '<div class="flex flex-wrap gap-1">' + tagsHTML + '</div>' +
                            '</div>' +
                            '<div class="notes-container">' +
                                '<div class="flex items-center mb-2">' +
                                    '<span class="text-xs text-gray-500 uppercase tracking-wide mr-3">Notes</span>' +
                                    '<button class="show-notes-btn text-xs text-blue-500 hover:text-blue-700 flex items-center" data-id="' + p.id + '" title="Show/Hide notes">' +
                                        '<i class="fas fa-eye mr-1"></i>Show' +
                                    '</button>' +
                                '</div>' +
                                '<div class="notes-content hidden" id="notes-container-' + p.id + '">' +
                                    '<textarea id="notes-content-' + p.id + '" class="w-full h-20 p-2 border border-gray-300 rounded text-sm text-gray-700 bg-white resize-vertical" readonly placeholder="Loading notes..."></textarea>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>';
                
                passwordCardContainer.appendChild(card);
            });
        }

        function renderTags(tags) {
            const tagListContainer = document.getElementById('tagList');
            if (!tagListContainer) return;
            tagListContainer.innerHTML = '';
            
            // Store all available tags for reference
            window.allAvailableTags = tags;
            
            // Filter out tags that are already in the password tags area
            const usedTagIds = Array.from(passwordTagsContainer.querySelectorAll('.tag-item')).map(tag => tag.dataset.id);
            const availableTags = tags.filter(tag => !usedTagIds.includes(tag.id.toString()));
            
            availableTags.forEach(tag => {
                const tagColor = getTagColor(tag.color);
                const tagElement = document.createElement('span');
                tagElement.className = 'tag-item text-xs font-semibold inline-block py-0.5 px-3 rounded border last:mr-0 mr-1 cursor-pointer break-all';
                tagElement.style.backgroundColor = tagColor;
                tagElement.style.color = getTextColor(tagColor);
                tagElement.style.border = getBorderStyle(tagColor);
                tagElement.dataset.id = tag.id;
                tagElement.dataset.name = tag.name;
                tagElement.dataset.color = tagColor;
                tagElement.draggable = true;
                tagElement.innerHTML = tag.name; // No edit/delete buttons on dashboard
                
                // Add click handler for mobile/touch devices
                tagElement.addEventListener('click', (e) => {
                    e.preventDefault();
                    addTagToPassword(tagElement);
                });
                
                // Add touch event for better mobile support
                tagElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    addTagToPassword(tagElement);
                });
                
                tagListContainer.appendChild(tagElement);
            });
            
            // Sort the available tags
            sortTagsInContainer(tagListContainer);
        }
        
        async function copyPassword(id) {
            try {
                const response = await authFetch(API_ORIGIN + '/api/passwords?id=' + id + '&action=copy');
                if (!response) return; // Auth error handled by authFetch
                if (!response.ok) throw new Error('Failed to fetch password for copying.');
                const password = await response.text();
                
                // Copy to clipboard using modern API with fallback
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(password);
                    } else {
                        // Fallback for older browsers or non-HTTPS
                        const tempInput = document.createElement('input');
                        tempInput.value = password;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);
                    }
                } catch (clipboardError) {
                    // Fallback if clipboard API fails
                    const tempInput = document.createElement('input');
                    tempInput.value = password;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                }
                
                // Show inline success message
                const messageElement = document.getElementById('copy-message-' + id);
                if (messageElement) {
                    messageElement.classList.remove('hidden');
                    // Auto-hide after 2 seconds
                    setTimeout(() => {
                        messageElement.classList.add('hidden');
                    }, 2000);
                }
            } catch (e) {
                console.error(e);
                // For errors, still use alert as it's important feedback
                alert('Failed to copy password: ' + e.message);
            }
        }

        async function showHidePassword(id) {
            const passwordInput = document.getElementById('password-' + id);
            const eyeIcon = document.querySelector('.show-password-btn[data-id="' + id + '"] i');
            
            if (passwordInput.type === 'password') {
                // Show password - fetch and display
                try {
                    const response = await authFetch(API_ORIGIN + '/api/passwords?id=' + id + '&action=copy');
                    if (!response) return; // Auth error handled by authFetch
                    if (!response.ok) throw new Error('Failed to fetch password.');
                    const password = await response.text();
                    passwordInput.value = password;
                    passwordInput.type = 'text';
                    eyeIcon.classList.remove('fa-eye');
                    eyeIcon.classList.add('fa-eye-slash');
                } catch (e) {
                    console.error(e);
                    alert('Failed to fetch password: ' + e.message);
                }
            } else {
                // Hide password
                passwordInput.value = '';
                passwordInput.type = 'password';
                eyeIcon.classList.remove('fa-eye-slash');
                eyeIcon.classList.add('fa-eye');
            }
        }

        async function showHideNotes(id) {
            const notesContainer = document.getElementById('notes-container-' + id);
            const notesContent = document.getElementById('notes-content-' + id);
            const showButton = document.querySelector('.show-notes-btn[data-id="' + id + '"]');
            
            if (notesContainer.classList.contains('hidden')) {
                // Show notes - fetch them if not already loaded
                if (notesContent.placeholder === 'Loading notes...') {
                    notesContent.value = 'Loading...';
                    try {
                        const response = await authFetch(API_ORIGIN + '/api/passwords?id=' + id);
                        if (!response) return; // Auth error handled by authFetch
                        if (response.ok) {
                            const password = await response.json();
                            const notesText = password.notes && password.notes.trim() ? password.notes : 'No notes available';
                            notesContent.value = notesText;
                            notesContent.placeholder = '';
                        } else {
                            notesContent.value = 'Failed to load notes';
                        }
                    } catch (error) {
                        notesContent.value = 'Error loading notes';
                    }
                }
                
                // Show the notes container
                notesContainer.classList.remove('hidden');
                showButton.innerHTML = '<i class="fas fa-eye-slash mr-1"></i>Hide';
                
            } else {
                // Hide notes container
                notesContainer.classList.add('hidden');
                showButton.innerHTML = '<i class="fas fa-eye mr-1"></i>Show';
            }
        }
    });
</script>
{{end}}
